#!/bin/bash
[[ -f $TMPDIR/.path_cache ]] && . $TMPDIR/.path_cache
#echo $PATH >$TMPDIR/.path_cache

rm -rf $TMPDIR/.path_cache_1*   # cleanup before processing
echo "INFO: removing fast path directories $TMPDIR/.path_cache_1*"  1>&2

[[ "$1" == restore ]] && echo "PATH=${OldPathValue:-${PATH}}" && exit 0
#
NewDir=1
BaseDir=100
NewPath=$TMPDIR/bin
#
for Target in $(echo $PATH | tr ':' '\n') 
do
  [[ ${Target} == ${TMPDIR}/bin ]] && continue
#
  ./link_files_in_dir ${Target}  ; status=$?  # status=2 means too many entries to be worth linking
#
  case ${status} in
    0) # reasonable number of entries in directory,  we will use soft links
       ((NewDir==1)) && \
       mkdir -p $TMPDIR/.path_cache_${BaseDir} && \
       NewPath="${NewPath}:$TMPDIR/.path_cache_${BaseDir}"
       ./link_files_in_dir ${Target} $TMPDIR/.path_cache_${BaseDir}
       printf ":%s" ${Target} >> $TMPDIR/.path_cache_${BaseDir}.src
       ((NewDir=0))
       ;;
    2) # too many entries in directory, we will link to the directory instead
       ((NewDir==0)) && ((BaseDir=BaseDir+1))
       ln -s ${Target} $TMPDIR/.path_cache_${BaseDir}
       NewPath="${NewPath}:$TMPDIR/.path_cache_${BaseDir}"
       printf "%s" ${Target} >> $TMPDIR/.path_cache_${BaseDir}.src
       ((NewDir=1))
       ((BaseDir=BaseDir+1))
       ;;
    *) exit ${status}     # serious error while trying to link
       ;;
  esac
done
echo "INFO: NEW PATH will be"   1>&2
echo "${NewPath}" | tr ':' '\n' 1>&2
echo "OldPathValue=${PATH}"    >$TMPDIR/.path_cache
echo "NewPathValue=${NewPath}" >>$TMPDIR/.path_cache
echo "PATH=${NewPath}"
