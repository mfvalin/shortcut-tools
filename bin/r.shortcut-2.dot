#      bash or ksh
[[ -z $RecursionLevel ]] && unset TaRgEts
((RecursionLevel > ${MaxRecursionLevel:-3})) && echo "WARNING: too many recursion levels (${RecursionLevel}>${MaxRecursionLevel})" && return
((RecursionLevel=RecursionLevel+1))
if [[ "$1" = -h || "$1" = --he* ]] ; then
  echo "usage: . r.shortcut.dot [-h|--help] [--list ] [--append] [--unuse] [--nobinbump] [--verbose] ITEM1 ... ITEMn"
  echo "NOTES: arguments are ORDER DEPENDENT, --append is deprecated and ignored"
  echo "Special tokens recognized: InOrder NoOrder FlushSsm Prepend Append (last 2 are ignored)"
  return
fi
[[ "$1" = -list || "$1" = --list ]] && shift && r.shortcuts
unset -f ssmuse || true
# SsMuSe=`which ssmuse`
function is_package
{
  typeset target
  for target in $*
  do
    [[ -d ${target}/../etc/ssm.d ]] && return
  done
  false
}
# function ssmuse
# {
#   ShElL=$1
#   shift
# #  echo ${SsMuSe} ${ShElL} "$@"
#   ${SsMuSe} ${ShElL} "$@"
#   unset ShElL || true
# }
function ssmuse_domain
{
 echo subscribing to $*
 eval "`ssmuse sh -d $*`"
}
#
#function ssmunuse_domain  # deprecated feature
#{
# echo unsubscribing from $*
# eval "`ssmuse sh -d ${1:-NO_DOMAIN}  | grep '^export' | sed -e 's/${[A-Z_]*}//' -e  's/=/ /' -e 's/^[ ]*export/. #r.unexport.dot/' -e 's/:/ /'`"
#}
#
StAtUs=0
#
if [[ "$1" = '-append' || "$1" = '--append' ]] ; then   shift ; fi # feature no longer supported by ssm, accepted and ignored for backward compatibility
#
# fonc='use'
add_unload=""
if [[ "$1" = '-unuse' || "$1" = '--unuse' ]] ; then  # will now work only for gnu/lmod modules 
#  fonc='unuse'
  add_unload="unload"
  shift
fi

NoBinBump=${NO_BIN_BUMP}
[[ "$1" = '-nobinbump' || "$1" = '--nobinbump' ]] && NoBinBump="NoBinBump"
# if [[ "$2" = "-p" ]]
# then
#   echo using $3@$1 instead of $1 -p $3
#   set -- $3@$1
# fi
echo shortcut${ENV_TEST_MODE}.dot "$@"
TaRgEts="$(r.resolve_shortcuts $*  2>$TMPDIR/resolve_messages_$$ | xargs) ${TaRgEts} "   # add before remaining targets
if((RecursionLevel>1)) ; then       # in recursive mode, do not unset variables nor undefine functions
 ((RecursionLevel=RecursionLevel-1))
 echo returning from level $RecursionLevel
 return
fi

${CMD_cat:-$(which cat)} $TMPDIR/resolve_messages_$$
${CMD_rm:-$(which rm)} -f $TMPDIR/resolve_messages_$$

#for TaRgEt in $(r.resolve_shortcuts${ENV_TEST_MODE} "$@" )
ModuleMode=Add
DelayedSsmuse=""
DelayedMode="YES"
which ssmuse-sh 2>/dev/null >/dev/null || DelayedMode=""
[[ -n ${DelayedMode} ]] && echo "INFO: using delayed mode"
NoOrder=""

while true
do
  TaRgEt=${TaRgEts%% *} ; TaRgEt=${TaRgEt%% }      # get first target from list, flush trailing blanks
  TaRgEts="${TaRgEts#* }"         # remove current target from list of targets
  [[ -z $TaRgEt ]] && break       # nothing left, quit
  for TeMp in ${ProcessedTaRgEts:-NotFoundHere} ; do [[ "$TeMp" == "$TaRgEt" ]] && echo "WARNING: duplicate shortcut: '$TaRgEt'" && TaRgEt="" && break ; done
  [[ -z $TaRgEt ]] && continue    # duplicate target, ignore it
  ProcessedTaRgEts="${ProcessedTaRgEts} ${TaRgEt}"  # add to processed target list
  export SSM_SHORTCUT="$TaRgEt"   # to be used if needed in module or .sh

  [[ "$TaRgEt" == Recur=* ]] && ((MaxRecursionLevel=${TaRgEt#*=})) && continue # max recursion depth control (default is 3)

  [[ "$TaRgEt" == Prepend || "$TaRgEt" == Append ]] && continue # deprecated items, accepted for backward compatibility

  [[ "$TaRgEt" == InOrder ]] && NoOrder="" && continue       # ssmuse-sh done when non ssm element encountered

  [[ "$TaRgEt" == NoOrder ]] && NoOrder="yes" && continue    # ssmuse-sh done at end

  [[ "$TaRgEt" == FlushSsm ]] && [[ -n "${DelayedSsmuse}" ]] && source ssmuse-sh ${DelayedSsmuse} && DelayedSsmuse="" && continue  # ssmuse-sh done NOW

# resolver detected error
  if [[ "$TaRgEt" == @* ]] ; then echo ERROR: NO SHORTCUT FOUND FOR ${TaRgEt#@} ; continue ; fi

# resolver marker for start/end of bundle, used to set/unset SHORTCUT_BUNDLE_PATH
  if [[ "$TaRgEt" == ++* ]] ; then export SHORTCUT_BUNDLE_PATH="${TaRgEt#++@}" ; continue ; fi

  [[ -n "${SHORTCUT_BUNDLE_PATH}" ]] && echo SHORTCUT BUNDLE PATH=${SHORTCUT_BUNDLE_PATH}

# package@domain, use true_path for fully qualified package (name_version_platform)
  if [[ -d "${TaRgEt#*@}/etc/ssm.d" && -d "${TaRgEt#*@}/${TaRgEt%@*}" ]] ; then
     echo USING PACKAGE "(fully qualified)" ${TaRgEt%@*} from DOMAIN $(true_path ${TaRgEt#*@})
     [[ -z ${DelayedMode} ]] && ssmuse_domain $(true_path ${TaRgEt#*@}) -p ${TaRgEt%@*}
     [[ -n ${DelayedMode} ]] && DelayedSsmuse="${DelayedSsmuse} -p $(true_path ${TaRgEt#*@})/${TaRgEt%@*}"
     continue
  fi

# package@domain, use true_path for NOT fully qualified package (name_version)
  if [[ -d "${TaRgEt#*@}/etc/ssm.d" ]] ; then
    if  is_package ${TaRgEt#*@}/${TaRgEt%@*}_*
    then
      echo USING PACKAGE ${TaRgEt%@*} from DOMAIN $(true_path ${TaRgEt#*@})
      [[ -z ${DelayedMode} ]] && ssmuse_domain $(true_path ${TaRgEt#*@}) -p ${TaRgEt%@*}
      [[ -n ${DelayedMode} ]] && DelayedSsmuse="${DelayedSsmuse} -p $(true_path ${TaRgEt#*@})/${TaRgEt%@*}"
      continue
    fi
  fi

# domain without cache or caching is disallowed
  if [[ -d "${TaRgEt}/etc/ssm.d" && ! ( -f "${TaRgEt}/cache.$BASE_ARCH" && "${ARCH_CACHE}" == yes ) ]] ; then 
    echo USING DOMAIN `true_path $TaRgEt`
    [[ -z ${DelayedMode} ]] && ssmuse_domain `true_path $TaRgEt`
    [[ -n ${DelayedMode} ]] && DelayedSsmuse="${DelayedSsmuse} -d $(true_path $TaRgEt)"
    continue
  fi

# non ssm element, process delayed ssmuse-sh unless in NoOrder mode
  [[ -n "${DelayedSsmuse}" ]] && [[ -z ${NoOrder} ]] && source ssmuse-sh ${DelayedSsmuse} && DelayedSsmuse=""

# domain with cache
  if [[ -f "${TaRgEt}/cache.$BASE_ARCH" && "${ARCH_CACHE}" == yes ]] ; then
      echo USING cache for DOMAIN `true_path $TaRgEt`
      . ${TaRgEt}/cache.$BASE_ARCH
      continue
  fi

# name.sh type shortcut
  if [[ "$TaRgEt" = *.sh && -r "$TaRgEt" ]] ;
  then 
    echo USING SHORTCUT $TaRgEt ;
    . $TaRgEt ;
    StAtUs_T=$? ; if [[ ${StAtUs_T} != 0 ]] ; then StAtUs=${StAtUs_T} ; fi
    if [[ ${StAtUs} == "111" ]] ; then echo "ERROR: abort requested by shortcut ${TaRgEt}" ; break ; fi
    if [[ ${StAtUs} == "110" ]] ; then echo "WARNING: break requested by shortcut ${TaRgEt}" ; StAtUs=0 ; break ; fi
    continue ;
  fi

# if we get to this point it must be a module
  if . module.dot ${add_unload:-add} ${TaRgEt} 2>&1 ; then
    echo "INFO: ${add_unload:-add} ${TaRgEt}"
    continue
  else
    echo "ERROR: abort requested by . module.dot ${add_unload:-add} ${TaRgEt}" ; StAtUs=1 ; break ;
  fi

# OOPS, nothing matches
  echo WARNING: NO SHORTCUT FOUND FOR ${TaRgEt}
done

# leftover delayed ssm elements
[[ -n "${DelayedSsmuse}" ]] && source ssmuse-sh ${DelayedSsmuse}

unset SSM_SHORTCUT || true
# cleanup of PATHS, creation of EC_INCLUDE_PATH and EC_LD_LIBRARY_PATH
. r.path_cleanup.dot

unset -f ssmuse_domain ssmunuse_domain ssmuse is_package || true
unset DelayedSsmuse NoBinBump fonc DoMaIn TaRgEt TaRgEts SHORTCUT_BUNDLE_PATH SSM_SHORTCUT RecursionLevel MaxRecursionLevel ProcessedTaRgEts TeMp || true
return ${StAtUs}
